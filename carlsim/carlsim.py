# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_carlsim')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_carlsim')
    _carlsim = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_carlsim', [dirname(__file__)])
        except ImportError:
            import _carlsim
            return _carlsim
        try:
            _mod = imp.load_module('_carlsim', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _carlsim = swig_import_helper()
    del swig_import_helper
else:
    import _carlsim
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _carlsim.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _carlsim.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _carlsim.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _carlsim.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _carlsim.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _carlsim.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _carlsim.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _carlsim.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _carlsim.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _carlsim.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _carlsim.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _carlsim.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _carlsim.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _carlsim.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _carlsim.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _carlsim.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _carlsim.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _carlsim.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _carlsim.SHARED_PTR_DISOWN
class vectori(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectori, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectori, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _carlsim.vectori_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _carlsim.vectori___nonzero__(self)

    def __bool__(self) -> "bool":
        return _carlsim.vectori___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _carlsim.vectori___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _carlsim.vectori___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _carlsim.vectori___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _carlsim.vectori___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _carlsim.vectori___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _carlsim.vectori___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _carlsim.vectori___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _carlsim.vectori_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _carlsim.vectori_append(self, x)

    def empty(self) -> "bool":
        return _carlsim.vectori_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _carlsim.vectori_size(self)

    def swap(self, v: 'vectori') -> "void":
        return _carlsim.vectori_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _carlsim.vectori_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _carlsim.vectori_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _carlsim.vectori_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _carlsim.vectori_rend(self)

    def clear(self) -> "void":
        return _carlsim.vectori_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _carlsim.vectori_get_allocator(self)

    def pop_back(self) -> "void":
        return _carlsim.vectori_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _carlsim.vectori_erase(self, *args)

    def __init__(self, *args):
        this = _carlsim.new_vectori(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _carlsim.vectori_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _carlsim.vectori_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _carlsim.vectori_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _carlsim.vectori_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _carlsim.vectori_resize(self, *args)

    def insert(self, *args) -> "void":
        return _carlsim.vectori_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _carlsim.vectori_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _carlsim.vectori_capacity(self)
    __swig_destroy__ = _carlsim.delete_vectori
    __del__ = lambda self: None
vectori_swigregister = _carlsim.vectori_swigregister
vectori_swigregister(vectori)

class vectord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _carlsim.vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _carlsim.vectord___nonzero__(self)

    def __bool__(self) -> "bool":
        return _carlsim.vectord___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _carlsim.vectord___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _carlsim.vectord___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _carlsim.vectord___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _carlsim.vectord___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _carlsim.vectord___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _carlsim.vectord___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _carlsim.vectord___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _carlsim.vectord_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _carlsim.vectord_append(self, x)

    def empty(self) -> "bool":
        return _carlsim.vectord_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _carlsim.vectord_size(self)

    def swap(self, v: 'vectord') -> "void":
        return _carlsim.vectord_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _carlsim.vectord_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _carlsim.vectord_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _carlsim.vectord_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _carlsim.vectord_rend(self)

    def clear(self) -> "void":
        return _carlsim.vectord_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _carlsim.vectord_get_allocator(self)

    def pop_back(self) -> "void":
        return _carlsim.vectord_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _carlsim.vectord_erase(self, *args)

    def __init__(self, *args):
        this = _carlsim.new_vectord(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _carlsim.vectord_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _carlsim.vectord_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _carlsim.vectord_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _carlsim.vectord_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _carlsim.vectord_resize(self, *args)

    def insert(self, *args) -> "void":
        return _carlsim.vectord_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _carlsim.vectord_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _carlsim.vectord_capacity(self)
    __swig_destroy__ = _carlsim.delete_vectord
    __del__ = lambda self: None
vectord_swigregister = _carlsim.vectord_swigregister
vectord_swigregister(vectord)

class vectorf(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorf, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _carlsim.vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _carlsim.vectorf___nonzero__(self)

    def __bool__(self) -> "bool":
        return _carlsim.vectorf___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _carlsim.vectorf___len__(self)

    def __getslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "std::vector< float,std::allocator< float > > *":
        return _carlsim.vectorf___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _carlsim.vectorf___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "void":
        return _carlsim.vectorf___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _carlsim.vectorf___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _carlsim.vectorf___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _carlsim.vectorf___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _carlsim.vectorf_pop(self)

    def append(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _carlsim.vectorf_append(self, x)

    def empty(self) -> "bool":
        return _carlsim.vectorf_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _carlsim.vectorf_size(self)

    def swap(self, v: 'vectorf') -> "void":
        return _carlsim.vectorf_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _carlsim.vectorf_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _carlsim.vectorf_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _carlsim.vectorf_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _carlsim.vectorf_rend(self)

    def clear(self) -> "void":
        return _carlsim.vectorf_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _carlsim.vectorf_get_allocator(self)

    def pop_back(self) -> "void":
        return _carlsim.vectorf_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _carlsim.vectorf_erase(self, *args)

    def __init__(self, *args):
        this = _carlsim.new_vectorf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _carlsim.vectorf_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _carlsim.vectorf_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _carlsim.vectorf_back(self)

    def assign(self, n: 'std::vector< float >::size_type', x: 'std::vector< float >::value_type const &') -> "void":
        return _carlsim.vectorf_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _carlsim.vectorf_resize(self, *args)

    def insert(self, *args) -> "void":
        return _carlsim.vectorf_insert(self, *args)

    def reserve(self, n: 'std::vector< float >::size_type') -> "void":
        return _carlsim.vectorf_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _carlsim.vectorf_capacity(self)
    __swig_destroy__ = _carlsim.delete_vectorf
    __del__ = lambda self: None
vectorf_swigregister = _carlsim.vectorf_swigregister
vectorf_swigregister(vectorf)

class vectorvf(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorvf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorvf, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _carlsim.vectorvf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _carlsim.vectorvf___nonzero__(self)

    def __bool__(self) -> "bool":
        return _carlsim.vectorvf___bool__(self)

    def __len__(self) -> "std::vector< std::vector< float > >::size_type":
        return _carlsim.vectorvf___len__(self)

    def __getslice__(self, i: 'std::vector< std::vector< float > >::difference_type', j: 'std::vector< std::vector< float > >::difference_type') -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > *":
        return _carlsim.vectorvf___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _carlsim.vectorvf___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::vector< float > >::difference_type', j: 'std::vector< std::vector< float > >::difference_type') -> "void":
        return _carlsim.vectorvf___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _carlsim.vectorvf___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< float > >::value_type const &":
        return _carlsim.vectorvf___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _carlsim.vectorvf___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< float > >::value_type":
        return _carlsim.vectorvf_pop(self)

    def append(self, x: 'vectorf') -> "void":
        return _carlsim.vectorvf_append(self, x)

    def empty(self) -> "bool":
        return _carlsim.vectorvf_empty(self)

    def size(self) -> "std::vector< std::vector< float > >::size_type":
        return _carlsim.vectorvf_size(self)

    def swap(self, v: 'vectorvf') -> "void":
        return _carlsim.vectorvf_swap(self, v)

    def begin(self) -> "std::vector< std::vector< float > >::iterator":
        return _carlsim.vectorvf_begin(self)

    def end(self) -> "std::vector< std::vector< float > >::iterator":
        return _carlsim.vectorvf_end(self)

    def rbegin(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        return _carlsim.vectorvf_rbegin(self)

    def rend(self) -> "std::vector< std::vector< float > >::reverse_iterator":
        return _carlsim.vectorvf_rend(self)

    def clear(self) -> "void":
        return _carlsim.vectorvf_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< float > >::allocator_type":
        return _carlsim.vectorvf_get_allocator(self)

    def pop_back(self) -> "void":
        return _carlsim.vectorvf_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< float > >::iterator":
        return _carlsim.vectorvf_erase(self, *args)

    def __init__(self, *args):
        this = _carlsim.new_vectorvf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'vectorf') -> "void":
        return _carlsim.vectorvf_push_back(self, x)

    def front(self) -> "std::vector< std::vector< float > >::value_type const &":
        return _carlsim.vectorvf_front(self)

    def back(self) -> "std::vector< std::vector< float > >::value_type const &":
        return _carlsim.vectorvf_back(self)

    def assign(self, n: 'std::vector< std::vector< float > >::size_type', x: 'vectorf') -> "void":
        return _carlsim.vectorvf_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _carlsim.vectorvf_resize(self, *args)

    def insert(self, *args) -> "void":
        return _carlsim.vectorvf_insert(self, *args)

    def reserve(self, n: 'std::vector< std::vector< float > >::size_type') -> "void":
        return _carlsim.vectorvf_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< float > >::size_type":
        return _carlsim.vectorvf_capacity(self)
    __swig_destroy__ = _carlsim.delete_vectorvf
    __del__ = lambda self: None
vectorvf_swigregister = _carlsim.vectorvf_swigregister
vectorvf_swigregister(vectorvf)

class vectorvi(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorvi, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorvi, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _carlsim.vectorvi_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _carlsim.vectorvi___nonzero__(self)

    def __bool__(self) -> "bool":
        return _carlsim.vectorvi___bool__(self)

    def __len__(self) -> "std::vector< std::vector< int > >::size_type":
        return _carlsim.vectorvi___len__(self)

    def __getslice__(self, i: 'std::vector< std::vector< int > >::difference_type', j: 'std::vector< std::vector< int > >::difference_type') -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *":
        return _carlsim.vectorvi___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _carlsim.vectorvi___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::vector< int > >::difference_type', j: 'std::vector< std::vector< int > >::difference_type') -> "void":
        return _carlsim.vectorvi___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _carlsim.vectorvi___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< int > >::value_type const &":
        return _carlsim.vectorvi___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _carlsim.vectorvi___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< int > >::value_type":
        return _carlsim.vectorvi_pop(self)

    def append(self, x: 'vectori') -> "void":
        return _carlsim.vectorvi_append(self, x)

    def empty(self) -> "bool":
        return _carlsim.vectorvi_empty(self)

    def size(self) -> "std::vector< std::vector< int > >::size_type":
        return _carlsim.vectorvi_size(self)

    def swap(self, v: 'vectorvi') -> "void":
        return _carlsim.vectorvi_swap(self, v)

    def begin(self) -> "std::vector< std::vector< int > >::iterator":
        return _carlsim.vectorvi_begin(self)

    def end(self) -> "std::vector< std::vector< int > >::iterator":
        return _carlsim.vectorvi_end(self)

    def rbegin(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        return _carlsim.vectorvi_rbegin(self)

    def rend(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        return _carlsim.vectorvi_rend(self)

    def clear(self) -> "void":
        return _carlsim.vectorvi_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< int > >::allocator_type":
        return _carlsim.vectorvi_get_allocator(self)

    def pop_back(self) -> "void":
        return _carlsim.vectorvi_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< int > >::iterator":
        return _carlsim.vectorvi_erase(self, *args)

    def __init__(self, *args):
        this = _carlsim.new_vectorvi(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'vectori') -> "void":
        return _carlsim.vectorvi_push_back(self, x)

    def front(self) -> "std::vector< std::vector< int > >::value_type const &":
        return _carlsim.vectorvi_front(self)

    def back(self) -> "std::vector< std::vector< int > >::value_type const &":
        return _carlsim.vectorvi_back(self)

    def assign(self, n: 'std::vector< std::vector< int > >::size_type', x: 'vectori') -> "void":
        return _carlsim.vectorvi_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _carlsim.vectorvi_resize(self, *args)

    def insert(self, *args) -> "void":
        return _carlsim.vectorvi_insert(self, *args)

    def reserve(self, n: 'std::vector< std::vector< int > >::size_type') -> "void":
        return _carlsim.vectorvi_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< int > >::size_type":
        return _carlsim.vectorvi_capacity(self)
    __swig_destroy__ = _carlsim.delete_vectorvi
    __del__ = lambda self: None
vectorvi_swigregister = _carlsim.vectorvi_swigregister
vectorvi_swigregister(vectorvi)

SYN_FIXED = _carlsim.SYN_FIXED
SYN_PLASTIC = _carlsim.SYN_PLASTIC
TARGET_AMPA = _carlsim.TARGET_AMPA
TARGET_NMDA = _carlsim.TARGET_NMDA
UNKNOWN_NEURON = _carlsim.UNKNOWN_NEURON
POISSON_NEURON = _carlsim.POISSON_NEURON
TARGET_GABAa = _carlsim.TARGET_GABAa
TARGET_GABAb = _carlsim.TARGET_GABAb
TARGET_DA = _carlsim.TARGET_DA
TARGET_5HT = _carlsim.TARGET_5HT
TARGET_ACh = _carlsim.TARGET_ACh
TARGET_NE = _carlsim.TARGET_NE
INHIBITORY_NEURON = _carlsim.INHIBITORY_NEURON
EXCITATORY_NEURON = _carlsim.EXCITATORY_NEURON
DOPAMINERGIC_NEURON = _carlsim.DOPAMINERGIC_NEURON
EXCITATORY_POISSON = _carlsim.EXCITATORY_POISSON
INHIBITORY_POISSON = _carlsim.INHIBITORY_POISSON
ALL = _carlsim.ALL
ANY = _carlsim.ANY
EXP_CURVE = _carlsim.EXP_CURVE
PULSE_CURVE = _carlsim.PULSE_CURVE
TIMING_BASED_CURVE = _carlsim.TIMING_BASED_CURVE
UNKNOWN_CURVE = _carlsim.UNKNOWN_CURVE
CPU_CORES = _carlsim.CPU_CORES
GPU_CORES = _carlsim.GPU_CORES
STANDARD = _carlsim.STANDARD
DA_MOD = _carlsim.DA_MOD
UNKNOWN_STDP = _carlsim.UNKNOWN_STDP
COUNT = _carlsim.COUNT
AER = _carlsim.AER
CPU_MODE = _carlsim.CPU_MODE
GPU_MODE = _carlsim.GPU_MODE
HYBRID_MODE = _carlsim.HYBRID_MODE
USER = _carlsim.USER
DEVELOPER = _carlsim.DEVELOPER
SHOWTIME = _carlsim.SHOWTIME
SILENT = _carlsim.SILENT
CUSTOM = _carlsim.CUSTOM
UNKNOWN_LOGGER = _carlsim.UNKNOWN_LOGGER
NM_DA = _carlsim.NM_DA
NM_5HT = _carlsim.NM_5HT
NM_ACh = _carlsim.NM_ACh
NM_NE = _carlsim.NM_NE
NM_UNKNOWN = _carlsim.NM_UNKNOWN
INTERVAL_10MS = _carlsim.INTERVAL_10MS
INTERVAL_100MS = _carlsim.INTERVAL_100MS
INTERVAL_1000MS = _carlsim.INTERVAL_1000MS
CONFIG_STATE = _carlsim.CONFIG_STATE
SETUP_STATE = _carlsim.SETUP_STATE
RUN_STATE = _carlsim.RUN_STATE
FORWARD_EULER = _carlsim.FORWARD_EULER
RUNGE_KUTTA4 = _carlsim.RUNGE_KUTTA4
UNKNOWN_INTEGRATION = _carlsim.UNKNOWN_INTEGRATION
class CARLsim(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CARLsim, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CARLsim, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _carlsim.new_CARLsim(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_CARLsim
    __del__ = lambda self: None

    def createSpikeGeneratorGroup(self, *args) -> "int":
        return _carlsim.CARLsim_createSpikeGeneratorGroup(self, *args)

    def createGroup(self, *args) -> "int":
        return _carlsim.CARLsim_createGroup(self, *args)

    def createGroupLIF(self, *args) -> "int":
        return _carlsim.CARLsim_createGroupLIF(self, *args)

    def connect(self, *args) -> "short":
        return _carlsim.CARLsim_connect(self, *args)

    def setConductances(self, *args) -> "void":
        return _carlsim.CARLsim_setConductances(self, *args)

    def setNeuronParameters(self, grpId: 'int', izh_a: 'float', izh_b: 'float', izh_c: 'float', izh_d: 'float') -> "void":
        return _carlsim.CARLsim_setNeuronParameters(self, grpId, izh_a, izh_b, izh_c, izh_d)

    def setNeuronParametersLIF(self, *args) -> "void":
        return _carlsim.CARLsim_setNeuronParametersLIF(self, *args)

    def setSpikeRate(self, grpId: 'int', spikeRate: 'PoissonRate', refPeriod: 'int'=1) -> "void":
        return _carlsim.CARLsim_setSpikeRate(self, grpId, spikeRate, refPeriod)

    def setConnectionMonitor(self, grpIdPre: 'int', grpIdPost: 'int', fname: 'std::string const &') -> "ConnectionMonitor *":
        return _carlsim.CARLsim_setConnectionMonitor(self, grpIdPre, grpIdPost, fname)

    def setGroupMonitor(self, grpId: 'int', fname: 'std::string const &') -> "GroupMonitor *":
        return _carlsim.CARLsim_setGroupMonitor(self, grpId, fname)

    def setSpikeMonitor(self, grpId: 'int', fileName: 'std::string const &') -> "SpikeMonitor *":
        return _carlsim.CARLsim_setSpikeMonitor(self, grpId, fileName)

    def setHomeostasis(self, *args) -> "void":
        return _carlsim.CARLsim_setHomeostasis(self, *args)

    def setHomeoBaseFiringRate(self, grpId: 'int', baseFiring: 'float', baseFiringSD: 'float'=0.0) -> "void":
        return _carlsim.CARLsim_setHomeoBaseFiringRate(self, grpId, baseFiring, baseFiringSD)

    def setNeuromodulator(self, grpId: 'int', baseDP: 'float', tauDP: 'float', base5HT: 'float', tau5HT: 'float', baseACh: 'float', tauACh: 'float', baseNE: 'float', tauNE: 'float') -> "void":
        return _carlsim.CARLsim_setNeuromodulator(self, grpId, baseDP, tauDP, base5HT, tau5HT, baseACh, tauACh, baseNE, tauNE)

    def setSTDP(self, *args) -> "void":
        return _carlsim.CARLsim_setSTDP(self, *args)

    def setESTDP(self, *args) -> "void":
        return _carlsim.CARLsim_setESTDP(self, *args)

    def setISTDP(self, *args) -> "void":
        return _carlsim.CARLsim_setISTDP(self, *args)

    def setSTP(self, *args) -> "void":
        return _carlsim.CARLsim_setSTP(self, *args)

    def setWeightAndWeightChangeUpdate(self, wtANDwtChangeUpdateInterval: 'UpdateInterval', enableWtChangeDecay: 'bool', wtChangeDecay: 'float'=0.9) -> "void":
        return _carlsim.CARLsim_setWeightAndWeightChangeUpdate(self, wtANDwtChangeUpdateInterval, enableWtChangeDecay, wtChangeDecay)

    def setWeight(self, connId: 'short', neurIdPre: 'int', neurIdPost: 'int', weight: 'float', updateWeightRange: 'bool'=False) -> "void":
        return _carlsim.CARLsim_setWeight(self, connId, neurIdPre, neurIdPost, weight, updateWeightRange)

    def saveSimulation(self, fileName: 'std::string const &', saveSynapseInfo: 'bool'=True) -> "void":
        return _carlsim.CARLsim_saveSimulation(self, fileName, saveSynapseInfo)

    def biasWeights(self, connId: 'short', bias: 'float', updateWeightRange: 'bool'=False) -> "void":
        return _carlsim.CARLsim_biasWeights(self, connId, bias, updateWeightRange)

    def loadSimulation(self, fid: 'FILE *') -> "void":
        return _carlsim.CARLsim_loadSimulation(self, fid)

    def scaleWeights(self, connId: 'short', scale: 'float', updateWeightRange: 'bool'=False) -> "void":
        return _carlsim.CARLsim_scaleWeights(self, connId, scale, updateWeightRange)

    def setExternalCurrent(self, *args) -> "void":
        return _carlsim.CARLsim_setExternalCurrent(self, *args)

    def setSpikeGenerator(self, grpId: 'int', spikeGenFunc: 'SpikeGenerator') -> "void":
        return _carlsim.CARLsim_setSpikeGenerator(self, grpId, spikeGenFunc)

    def getSpikeMonitor(self, grpId: 'int') -> "SpikeMonitor *":
        return _carlsim.CARLsim_getSpikeMonitor(self, grpId)

    def getSimTime(self) -> "int":
        return _carlsim.CARLsim_getSimTime(self)

    def getSimTimeSec(self) -> "int":
        return _carlsim.CARLsim_getSimTimeSec(self)

    def getSimTimeMsec(self) -> "int":
        return _carlsim.CARLsim_getSimTimeMsec(self)

    def getGroupName(self, grpId: 'int') -> "std::string":
        return _carlsim.CARLsim_getGroupName(self, grpId)

    def getNumSynapticConnections(self, connectionId: 'short') -> "int":
        return _carlsim.CARLsim_getNumSynapticConnections(self, connectionId)

    def setIntegrationMethod(self, method: 'integrationMethod_t', numStepsPerMs: 'int') -> "void":
        return _carlsim.CARLsim_setIntegrationMethod(self, method, numStepsPerMs)

    def getGroupGrid3D(self, gId: 'int') -> "Grid3D":
        return _carlsim.CARLsim_getGroupGrid3D(self, gId)

    def startTesting(self, updateWeights: 'bool'=True) -> "void":
        return _carlsim.CARLsim_startTesting(self, updateWeights)

    def stopTesting(self) -> "void":
        return _carlsim.CARLsim_stopTesting(self)

    def setupNetwork(self) -> "void":
        return _carlsim.CARLsim_setupNetwork(self)

    def runNetwork(self, nSec: 'int', nMsec: 'int'=0, printRunSummary: 'bool'=True) -> "int":
        return _carlsim.CARLsim_runNetwork(self, nSec, nMsec, printRunSummary)
CARLsim_swigregister = _carlsim.CARLsim_swigregister
CARLsim_swigregister(CARLsim)

class PoissonRate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PoissonRate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PoissonRate, name)
    __repr__ = _swig_repr

    def __init__(self, nNeur: 'int', onGPU: 'bool'=False):
        this = _carlsim.new_PoissonRate(nNeur, onGPU)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_PoissonRate
    __del__ = lambda self: None

    def getNumNeurons(self) -> "int":
        return _carlsim.PoissonRate_getNumNeurons(self)

    def getRate(self, neurId: 'int') -> "float":
        return _carlsim.PoissonRate_getRate(self, neurId)

    def getRates(self) -> "std::vector< float,std::allocator< float > >":
        return _carlsim.PoissonRate_getRates(self)

    def setRate(self, neurId: 'int', rate: 'float') -> "void":
        return _carlsim.PoissonRate_setRate(self, neurId, rate)

    def setRates(self, *args) -> "void":
        return _carlsim.PoissonRate_setRates(self, *args)
PoissonRate_swigregister = _carlsim.PoissonRate_swigregister
PoissonRate_swigregister(PoissonRate)

class ConnectionMonitor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionMonitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionMonitor, name)
    __repr__ = _swig_repr

    def __init__(self, connMonCorePtr: 'ConnectionMonitorCore *'):
        this = _carlsim.new_ConnectionMonitor(connMonCorePtr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_ConnectionMonitor
    __del__ = lambda self: None

    def calcWeightChanges(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _carlsim.ConnectionMonitor_calcWeightChanges(self)

    def getConnectId(self) -> "short":
        return _carlsim.ConnectionMonitor_getConnectId(self)

    def getMaxWeight(self, getCurrent: 'bool'=False) -> "double":
        return _carlsim.ConnectionMonitor_getMaxWeight(self, getCurrent)

    def getMinWeight(self, getCurrent: 'bool'=False) -> "double":
        return _carlsim.ConnectionMonitor_getMinWeight(self, getCurrent)

    def getNumNeuronsPre(self) -> "int":
        return _carlsim.ConnectionMonitor_getNumNeuronsPre(self)

    def getNumNeuronsPost(self) -> "int":
        return _carlsim.ConnectionMonitor_getNumNeuronsPost(self)

    def getNumSynapses(self) -> "int":
        return _carlsim.ConnectionMonitor_getNumSynapses(self)

    def getNumWeightsChanged(self, minAbsChanged: 'double'=1e-5) -> "int":
        return _carlsim.ConnectionMonitor_getNumWeightsChanged(self, minAbsChanged)

    def getNumWeightsInRange(self, minValue: 'double', maxValue: 'double') -> "int":
        return _carlsim.ConnectionMonitor_getNumWeightsInRange(self, minValue, maxValue)

    def getNumWeightsWithValue(self, value: 'double') -> "int":
        return _carlsim.ConnectionMonitor_getNumWeightsWithValue(self, value)

    def getPercentWeightsInRange(self, minValue: 'double', maxValue: 'double') -> "double":
        return _carlsim.ConnectionMonitor_getPercentWeightsInRange(self, minValue, maxValue)

    def getPercentWeightsWithValue(self, value: 'double') -> "double":
        return _carlsim.ConnectionMonitor_getPercentWeightsWithValue(self, value)

    def getPercentWeightsChanged(self, minAbsChanged: 'double'=1e-5) -> "double":
        return _carlsim.ConnectionMonitor_getPercentWeightsChanged(self, minAbsChanged)

    def getTimeMsCurrentSnapshot(self) -> "long":
        return _carlsim.ConnectionMonitor_getTimeMsCurrentSnapshot(self)

    def getTimeMsLastSnapshot(self) -> "long":
        return _carlsim.ConnectionMonitor_getTimeMsLastSnapshot(self)

    def getTimeMsSinceLastSnapshot(self) -> "long":
        return _carlsim.ConnectionMonitor_getTimeMsSinceLastSnapshot(self)

    def getTotalAbsWeightChange(self) -> "double":
        return _carlsim.ConnectionMonitor_getTotalAbsWeightChange(self)

    def _print(self) -> "void":
        return _carlsim.ConnectionMonitor__print(self)

    def printSparse(self, neurPostId: 'int'=-1, maxConn: 'int'=100, connPerLine: 'int'=4) -> "void":
        return _carlsim.ConnectionMonitor_printSparse(self, neurPostId, maxConn, connPerLine)

    def takeSnapshot(self) -> "std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >":
        return _carlsim.ConnectionMonitor_takeSnapshot(self)

    def takeSnapshot1D(self) -> "std::vector< float,std::allocator< float > >":
        return _carlsim.ConnectionMonitor_takeSnapshot1D(self)

    def testPrint(self, data: 'vectori') -> "void":
        return _carlsim.ConnectionMonitor_testPrint(self, data)
ConnectionMonitor_swigregister = _carlsim.ConnectionMonitor_swigregister
ConnectionMonitor_swigregister(ConnectionMonitor)

class GroupMonitor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GroupMonitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GroupMonitor, name)
    __repr__ = _swig_repr

    def __init__(self, groupMonitorCorePtr: 'GroupMonitorCore *'):
        this = _carlsim.new_GroupMonitor(groupMonitorCorePtr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_GroupMonitor
    __del__ = lambda self: None

    def isRecording(self) -> "bool":
        return _carlsim.GroupMonitor_isRecording(self)

    def startRecording(self) -> "void":
        return _carlsim.GroupMonitor_startRecording(self)

    def stopRecording(self) -> "void":
        return _carlsim.GroupMonitor_stopRecording(self)

    def getRecordingTotalTime(self) -> "int":
        return _carlsim.GroupMonitor_getRecordingTotalTime(self)

    def getRecordingLastStartTime(self) -> "int":
        return _carlsim.GroupMonitor_getRecordingLastStartTime(self)

    def getRecordingStartTime(self) -> "int":
        return _carlsim.GroupMonitor_getRecordingStartTime(self)

    def getRecordingStopTime(self) -> "int":
        return _carlsim.GroupMonitor_getRecordingStopTime(self)

    def getPersistentData(self) -> "bool":
        return _carlsim.GroupMonitor_getPersistentData(self)

    def setPersistentData(self, persistentData: 'bool') -> "void":
        return _carlsim.GroupMonitor_setPersistentData(self, persistentData)

    def getDataVector(self) -> "std::vector< float,std::allocator< float > >":
        return _carlsim.GroupMonitor_getDataVector(self)

    def getPeakValueVector(self) -> "std::vector< float,std::allocator< float > >":
        return _carlsim.GroupMonitor_getPeakValueVector(self)

    def getPeakTimeVector(self) -> "std::vector< int,std::allocator< int > >":
        return _carlsim.GroupMonitor_getPeakTimeVector(self)

    def getSortedPeakValueVector(self) -> "std::vector< float,std::allocator< float > >":
        return _carlsim.GroupMonitor_getSortedPeakValueVector(self)

    def getSortedPeakTimeVector(self) -> "std::vector< int,std::allocator< int > >":
        return _carlsim.GroupMonitor_getSortedPeakTimeVector(self)
GroupMonitor_swigregister = _carlsim.GroupMonitor_swigregister
GroupMonitor_swigregister(GroupMonitor)

class SpikeMonitor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpikeMonitor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpikeMonitor, name)
    __repr__ = _swig_repr

    def __init__(self, spikeMonitorCorePtr: 'SpikeMonitorCore *'):
        this = _carlsim.new_SpikeMonitor(spikeMonitorCorePtr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_SpikeMonitor
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _carlsim.SpikeMonitor_clear(self)

    def getAllFiringRates(self) -> "std::vector< float,std::allocator< float > >":
        return _carlsim.SpikeMonitor_getAllFiringRates(self)

    def getAllFiringRatesSorted(self) -> "std::vector< float,std::allocator< float > >":
        return _carlsim.SpikeMonitor_getAllFiringRatesSorted(self)

    def getMaxFiringRate(self) -> "float":
        return _carlsim.SpikeMonitor_getMaxFiringRate(self)

    def getMinFiringRate(self) -> "float":
        return _carlsim.SpikeMonitor_getMinFiringRate(self)

    def getNeuronMeanFiringRate(self, neurId: 'int') -> "float":
        return _carlsim.SpikeMonitor_getNeuronMeanFiringRate(self, neurId)

    def getNeuronNumSpikes(self, neurId: 'int') -> "int":
        return _carlsim.SpikeMonitor_getNeuronNumSpikes(self, neurId)

    def getNumNeuronsWithFiringRate(self, min: 'float', max: 'float') -> "int":
        return _carlsim.SpikeMonitor_getNumNeuronsWithFiringRate(self, min, max)

    def getNumSilentNeurons(self) -> "int":
        return _carlsim.SpikeMonitor_getNumSilentNeurons(self)

    def getPercentNeuronsWithFiringRate(self, min: 'float', max: 'float') -> "float":
        return _carlsim.SpikeMonitor_getPercentNeuronsWithFiringRate(self, min, max)

    def getPercentSilentNeurons(self) -> "float":
        return _carlsim.SpikeMonitor_getPercentSilentNeurons(self)

    def getPopMeanFiringRate(self) -> "float":
        return _carlsim.SpikeMonitor_getPopMeanFiringRate(self)

    def getPopStdFiringRate(self) -> "float":
        return _carlsim.SpikeMonitor_getPopStdFiringRate(self)

    def getPopNumSpikes(self) -> "int":
        return _carlsim.SpikeMonitor_getPopNumSpikes(self)

    def getSpikeVector2D(self) -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >":
        return _carlsim.SpikeMonitor_getSpikeVector2D(self)

    def isRecording(self) -> "bool":
        return _carlsim.SpikeMonitor_isRecording(self)

    def _print(self, printSpikeTimes: 'bool'=True) -> "void":
        return _carlsim.SpikeMonitor__print(self, printSpikeTimes)

    def startRecording(self) -> "void":
        return _carlsim.SpikeMonitor_startRecording(self)

    def stopRecording(self) -> "void":
        return _carlsim.SpikeMonitor_stopRecording(self)

    def getRecordingTotalTime(self) -> "long":
        return _carlsim.SpikeMonitor_getRecordingTotalTime(self)

    def getRecordingLastStartTime(self) -> "long":
        return _carlsim.SpikeMonitor_getRecordingLastStartTime(self)

    def getRecordingStartTime(self) -> "long":
        return _carlsim.SpikeMonitor_getRecordingStartTime(self)

    def getRecordingStopTime(self) -> "long":
        return _carlsim.SpikeMonitor_getRecordingStopTime(self)

    def getPersistentData(self) -> "bool":
        return _carlsim.SpikeMonitor_getPersistentData(self)

    def setPersistentData(self, persistentData: 'bool') -> "void":
        return _carlsim.SpikeMonitor_setPersistentData(self, persistentData)

    def getMode(self) -> "SpikeMonMode":
        return _carlsim.SpikeMonitor_getMode(self)

    def setMode(self, mode: 'SpikeMonMode'=AER) -> "void":
        return _carlsim.SpikeMonitor_setMode(self, mode)

    def setLogFile(self, logFileName: 'std::string const &') -> "void":
        return _carlsim.SpikeMonitor_setLogFile(self, logFileName)
SpikeMonitor_swigregister = _carlsim.SpikeMonitor_swigregister
SpikeMonitor_swigregister(SpikeMonitor)

class SpikeGenerator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpikeGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpikeGenerator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _carlsim.delete_SpikeGenerator
    __del__ = lambda self: None

    def nextSpikeTime(self, s: 'CARLsim', grpId: 'int', i: 'int', currentTime: 'int', lastScheduledSpikeTime: 'int', endOfTimeSlice: 'int') -> "int":
        return _carlsim.SpikeGenerator_nextSpikeTime(self, s, grpId, i, currentTime, lastScheduledSpikeTime, endOfTimeSlice)
SpikeGenerator_swigregister = _carlsim.SpikeGenerator_swigregister
SpikeGenerator_swigregister(SpikeGenerator)

class ConnectionGenerator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConnectionGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConnectionGenerator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _carlsim.delete_ConnectionGenerator
    __del__ = lambda self: None

    def connect(self, s: 'CARLsim', srcGrpId: 'int', i: 'int', destGrpId: 'int', j: 'int', weight: 'float &', maxWt: 'float &', delay: 'float &', connected: 'bool &') -> "void":
        return _carlsim.ConnectionGenerator_connect(self, s, srcGrpId, i, destGrpId, j, weight, maxWt, delay, connected)
ConnectionGenerator_swigregister = _carlsim.ConnectionGenerator_swigregister
ConnectionGenerator_swigregister(ConnectionGenerator)

class SpikeGeneratorFromVector(SpikeGenerator):
    __swig_setmethods__ = {}
    for _s in [SpikeGenerator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpikeGeneratorFromVector, name, value)
    __swig_getmethods__ = {}
    for _s in [SpikeGenerator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpikeGeneratorFromVector, name)
    __repr__ = _swig_repr

    def __init__(self, spkTimes: 'vectori'):
        this = _carlsim.new_SpikeGeneratorFromVector(spkTimes)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_SpikeGeneratorFromVector
    __del__ = lambda self: None

    def nextSpikeTime(self, sim: 'CARLsim', grpId: 'int', nid: 'int', currentTime: 'int', lastScheduledSpikeTime: 'int', endOfTimeSlice: 'int') -> "int":
        return _carlsim.SpikeGeneratorFromVector_nextSpikeTime(self, sim, grpId, nid, currentTime, lastScheduledSpikeTime, endOfTimeSlice)
SpikeGeneratorFromVector_swigregister = _carlsim.SpikeGeneratorFromVector_swigregister
SpikeGeneratorFromVector_swigregister(SpikeGeneratorFromVector)

class VisualStimulus(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VisualStimulus, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VisualStimulus, name)
    __repr__ = _swig_repr

    def __init__(self, fileName: 'std::string', wrapAroundEOF: 'bool'=True):
        this = _carlsim.new_VisualStimulus(fileName, wrapAroundEOF)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_VisualStimulus
    __del__ = lambda self: None

    def readFrameChar(self) -> "unsigned char *":
        return _carlsim.VisualStimulus_readFrameChar(self)

    def readFramePoisson(self, maxPoisson: 'float', minPoisson: 'float'=0.0) -> "PoissonRate *":
        return _carlsim.VisualStimulus_readFramePoisson(self, maxPoisson, minPoisson)

    def rewind(self) -> "void":
        return _carlsim.VisualStimulus_rewind(self)

    def _print(self) -> "void":
        return _carlsim.VisualStimulus__print(self)

    def getWidth(self) -> "int":
        return _carlsim.VisualStimulus_getWidth(self)

    def getHeight(self) -> "int":
        return _carlsim.VisualStimulus_getHeight(self)

    def getLength(self) -> "int":
        return _carlsim.VisualStimulus_getLength(self)

    def getChannels(self) -> "int":
        return _carlsim.VisualStimulus_getChannels(self)

    def getType(self) -> "stimType_t":
        return _carlsim.VisualStimulus_getType(self)

    def getCurrentFrameChar(self) -> "unsigned char *":
        return _carlsim.VisualStimulus_getCurrentFrameChar(self)

    def getCurrentFramePoisson(self) -> "PoissonRate *":
        return _carlsim.VisualStimulus_getCurrentFramePoisson(self)

    def getCurrentFrameNumber(self) -> "int":
        return _carlsim.VisualStimulus_getCurrentFrameNumber(self)
VisualStimulus_swigregister = _carlsim.VisualStimulus_swigregister
VisualStimulus_swigregister(VisualStimulus)

class Grid3D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Grid3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Grid3D, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _carlsim.new_Grid3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["numX"] = _carlsim.Grid3D_numX_set
    __swig_getmethods__["numX"] = _carlsim.Grid3D_numX_get
    if _newclass:
        numX = _swig_property(_carlsim.Grid3D_numX_get, _carlsim.Grid3D_numX_set)
    __swig_setmethods__["numY"] = _carlsim.Grid3D_numY_set
    __swig_getmethods__["numY"] = _carlsim.Grid3D_numY_get
    if _newclass:
        numY = _swig_property(_carlsim.Grid3D_numY_get, _carlsim.Grid3D_numY_set)
    __swig_setmethods__["numZ"] = _carlsim.Grid3D_numZ_set
    __swig_getmethods__["numZ"] = _carlsim.Grid3D_numZ_get
    if _newclass:
        numZ = _swig_property(_carlsim.Grid3D_numZ_get, _carlsim.Grid3D_numZ_set)
    __swig_setmethods__["distX"] = _carlsim.Grid3D_distX_set
    __swig_getmethods__["distX"] = _carlsim.Grid3D_distX_get
    if _newclass:
        distX = _swig_property(_carlsim.Grid3D_distX_get, _carlsim.Grid3D_distX_set)
    __swig_setmethods__["distY"] = _carlsim.Grid3D_distY_set
    __swig_getmethods__["distY"] = _carlsim.Grid3D_distY_get
    if _newclass:
        distY = _swig_property(_carlsim.Grid3D_distY_get, _carlsim.Grid3D_distY_set)
    __swig_setmethods__["distZ"] = _carlsim.Grid3D_distZ_set
    __swig_getmethods__["distZ"] = _carlsim.Grid3D_distZ_get
    if _newclass:
        distZ = _swig_property(_carlsim.Grid3D_distZ_get, _carlsim.Grid3D_distZ_set)
    __swig_setmethods__["offsetX"] = _carlsim.Grid3D_offsetX_set
    __swig_getmethods__["offsetX"] = _carlsim.Grid3D_offsetX_get
    if _newclass:
        offsetX = _swig_property(_carlsim.Grid3D_offsetX_get, _carlsim.Grid3D_offsetX_set)
    __swig_setmethods__["offsetY"] = _carlsim.Grid3D_offsetY_set
    __swig_getmethods__["offsetY"] = _carlsim.Grid3D_offsetY_get
    if _newclass:
        offsetY = _swig_property(_carlsim.Grid3D_offsetY_get, _carlsim.Grid3D_offsetY_set)
    __swig_setmethods__["offsetZ"] = _carlsim.Grid3D_offsetZ_set
    __swig_getmethods__["offsetZ"] = _carlsim.Grid3D_offsetZ_get
    if _newclass:
        offsetZ = _swig_property(_carlsim.Grid3D_offsetZ_get, _carlsim.Grid3D_offsetZ_set)
    __swig_setmethods__["N"] = _carlsim.Grid3D_N_set
    __swig_getmethods__["N"] = _carlsim.Grid3D_N_get
    if _newclass:
        N = _swig_property(_carlsim.Grid3D_N_get, _carlsim.Grid3D_N_set)
    __swig_destroy__ = _carlsim.delete_Grid3D
    __del__ = lambda self: None
Grid3D_swigregister = _carlsim.Grid3D_swigregister
Grid3D_swigregister(Grid3D)

class GroupSTDPInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GroupSTDPInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GroupSTDPInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["WithSTDP"] = _carlsim.GroupSTDPInfo_WithSTDP_set
    __swig_getmethods__["WithSTDP"] = _carlsim.GroupSTDPInfo_WithSTDP_get
    if _newclass:
        WithSTDP = _swig_property(_carlsim.GroupSTDPInfo_WithSTDP_get, _carlsim.GroupSTDPInfo_WithSTDP_set)
    __swig_setmethods__["WithESTDP"] = _carlsim.GroupSTDPInfo_WithESTDP_set
    __swig_getmethods__["WithESTDP"] = _carlsim.GroupSTDPInfo_WithESTDP_get
    if _newclass:
        WithESTDP = _swig_property(_carlsim.GroupSTDPInfo_WithESTDP_get, _carlsim.GroupSTDPInfo_WithESTDP_set)
    __swig_setmethods__["WithISTDP"] = _carlsim.GroupSTDPInfo_WithISTDP_set
    __swig_getmethods__["WithISTDP"] = _carlsim.GroupSTDPInfo_WithISTDP_get
    if _newclass:
        WithISTDP = _swig_property(_carlsim.GroupSTDPInfo_WithISTDP_get, _carlsim.GroupSTDPInfo_WithISTDP_set)
    __swig_setmethods__["WithESTDPtype"] = _carlsim.GroupSTDPInfo_WithESTDPtype_set
    __swig_getmethods__["WithESTDPtype"] = _carlsim.GroupSTDPInfo_WithESTDPtype_get
    if _newclass:
        WithESTDPtype = _swig_property(_carlsim.GroupSTDPInfo_WithESTDPtype_get, _carlsim.GroupSTDPInfo_WithESTDPtype_set)
    __swig_setmethods__["WithISTDPtype"] = _carlsim.GroupSTDPInfo_WithISTDPtype_set
    __swig_getmethods__["WithISTDPtype"] = _carlsim.GroupSTDPInfo_WithISTDPtype_get
    if _newclass:
        WithISTDPtype = _swig_property(_carlsim.GroupSTDPInfo_WithISTDPtype_get, _carlsim.GroupSTDPInfo_WithISTDPtype_set)
    __swig_setmethods__["WithESTDPcurve"] = _carlsim.GroupSTDPInfo_WithESTDPcurve_set
    __swig_getmethods__["WithESTDPcurve"] = _carlsim.GroupSTDPInfo_WithESTDPcurve_get
    if _newclass:
        WithESTDPcurve = _swig_property(_carlsim.GroupSTDPInfo_WithESTDPcurve_get, _carlsim.GroupSTDPInfo_WithESTDPcurve_set)
    __swig_setmethods__["WithISTDPcurve"] = _carlsim.GroupSTDPInfo_WithISTDPcurve_set
    __swig_getmethods__["WithISTDPcurve"] = _carlsim.GroupSTDPInfo_WithISTDPcurve_get
    if _newclass:
        WithISTDPcurve = _swig_property(_carlsim.GroupSTDPInfo_WithISTDPcurve_get, _carlsim.GroupSTDPInfo_WithISTDPcurve_set)
    __swig_setmethods__["TAU_PLUS_INV_EXC"] = _carlsim.GroupSTDPInfo_TAU_PLUS_INV_EXC_set
    __swig_getmethods__["TAU_PLUS_INV_EXC"] = _carlsim.GroupSTDPInfo_TAU_PLUS_INV_EXC_get
    if _newclass:
        TAU_PLUS_INV_EXC = _swig_property(_carlsim.GroupSTDPInfo_TAU_PLUS_INV_EXC_get, _carlsim.GroupSTDPInfo_TAU_PLUS_INV_EXC_set)
    __swig_setmethods__["TAU_MINUS_INV_EXC"] = _carlsim.GroupSTDPInfo_TAU_MINUS_INV_EXC_set
    __swig_getmethods__["TAU_MINUS_INV_EXC"] = _carlsim.GroupSTDPInfo_TAU_MINUS_INV_EXC_get
    if _newclass:
        TAU_MINUS_INV_EXC = _swig_property(_carlsim.GroupSTDPInfo_TAU_MINUS_INV_EXC_get, _carlsim.GroupSTDPInfo_TAU_MINUS_INV_EXC_set)
    __swig_setmethods__["ALPHA_PLUS_EXC"] = _carlsim.GroupSTDPInfo_ALPHA_PLUS_EXC_set
    __swig_getmethods__["ALPHA_PLUS_EXC"] = _carlsim.GroupSTDPInfo_ALPHA_PLUS_EXC_get
    if _newclass:
        ALPHA_PLUS_EXC = _swig_property(_carlsim.GroupSTDPInfo_ALPHA_PLUS_EXC_get, _carlsim.GroupSTDPInfo_ALPHA_PLUS_EXC_set)
    __swig_setmethods__["ALPHA_MINUS_EXC"] = _carlsim.GroupSTDPInfo_ALPHA_MINUS_EXC_set
    __swig_getmethods__["ALPHA_MINUS_EXC"] = _carlsim.GroupSTDPInfo_ALPHA_MINUS_EXC_get
    if _newclass:
        ALPHA_MINUS_EXC = _swig_property(_carlsim.GroupSTDPInfo_ALPHA_MINUS_EXC_get, _carlsim.GroupSTDPInfo_ALPHA_MINUS_EXC_set)
    __swig_setmethods__["TAU_PLUS_INV_INB"] = _carlsim.GroupSTDPInfo_TAU_PLUS_INV_INB_set
    __swig_getmethods__["TAU_PLUS_INV_INB"] = _carlsim.GroupSTDPInfo_TAU_PLUS_INV_INB_get
    if _newclass:
        TAU_PLUS_INV_INB = _swig_property(_carlsim.GroupSTDPInfo_TAU_PLUS_INV_INB_get, _carlsim.GroupSTDPInfo_TAU_PLUS_INV_INB_set)
    __swig_setmethods__["TAU_MINUS_INV_INB"] = _carlsim.GroupSTDPInfo_TAU_MINUS_INV_INB_set
    __swig_getmethods__["TAU_MINUS_INV_INB"] = _carlsim.GroupSTDPInfo_TAU_MINUS_INV_INB_get
    if _newclass:
        TAU_MINUS_INV_INB = _swig_property(_carlsim.GroupSTDPInfo_TAU_MINUS_INV_INB_get, _carlsim.GroupSTDPInfo_TAU_MINUS_INV_INB_set)
    __swig_setmethods__["ALPHA_PLUS_INB"] = _carlsim.GroupSTDPInfo_ALPHA_PLUS_INB_set
    __swig_getmethods__["ALPHA_PLUS_INB"] = _carlsim.GroupSTDPInfo_ALPHA_PLUS_INB_get
    if _newclass:
        ALPHA_PLUS_INB = _swig_property(_carlsim.GroupSTDPInfo_ALPHA_PLUS_INB_get, _carlsim.GroupSTDPInfo_ALPHA_PLUS_INB_set)
    __swig_setmethods__["ALPHA_MINUS_INB"] = _carlsim.GroupSTDPInfo_ALPHA_MINUS_INB_set
    __swig_getmethods__["ALPHA_MINUS_INB"] = _carlsim.GroupSTDPInfo_ALPHA_MINUS_INB_get
    if _newclass:
        ALPHA_MINUS_INB = _swig_property(_carlsim.GroupSTDPInfo_ALPHA_MINUS_INB_get, _carlsim.GroupSTDPInfo_ALPHA_MINUS_INB_set)
    __swig_setmethods__["GAMMA"] = _carlsim.GroupSTDPInfo_GAMMA_set
    __swig_getmethods__["GAMMA"] = _carlsim.GroupSTDPInfo_GAMMA_get
    if _newclass:
        GAMMA = _swig_property(_carlsim.GroupSTDPInfo_GAMMA_get, _carlsim.GroupSTDPInfo_GAMMA_set)
    __swig_setmethods__["BETA_LTP"] = _carlsim.GroupSTDPInfo_BETA_LTP_set
    __swig_getmethods__["BETA_LTP"] = _carlsim.GroupSTDPInfo_BETA_LTP_get
    if _newclass:
        BETA_LTP = _swig_property(_carlsim.GroupSTDPInfo_BETA_LTP_get, _carlsim.GroupSTDPInfo_BETA_LTP_set)
    __swig_setmethods__["BETA_LTD"] = _carlsim.GroupSTDPInfo_BETA_LTD_set
    __swig_getmethods__["BETA_LTD"] = _carlsim.GroupSTDPInfo_BETA_LTD_get
    if _newclass:
        BETA_LTD = _swig_property(_carlsim.GroupSTDPInfo_BETA_LTD_get, _carlsim.GroupSTDPInfo_BETA_LTD_set)
    __swig_setmethods__["LAMBDA"] = _carlsim.GroupSTDPInfo_LAMBDA_set
    __swig_getmethods__["LAMBDA"] = _carlsim.GroupSTDPInfo_LAMBDA_get
    if _newclass:
        LAMBDA = _swig_property(_carlsim.GroupSTDPInfo_LAMBDA_get, _carlsim.GroupSTDPInfo_LAMBDA_set)
    __swig_setmethods__["DELTA"] = _carlsim.GroupSTDPInfo_DELTA_set
    __swig_getmethods__["DELTA"] = _carlsim.GroupSTDPInfo_DELTA_get
    if _newclass:
        DELTA = _swig_property(_carlsim.GroupSTDPInfo_DELTA_get, _carlsim.GroupSTDPInfo_DELTA_set)

    def __init__(self):
        this = _carlsim.new_GroupSTDPInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_GroupSTDPInfo
    __del__ = lambda self: None
GroupSTDPInfo_swigregister = _carlsim.GroupSTDPInfo_swigregister
GroupSTDPInfo_swigregister(GroupSTDPInfo)

class GroupNeuromodulatorInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GroupNeuromodulatorInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GroupNeuromodulatorInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["baseDP"] = _carlsim.GroupNeuromodulatorInfo_baseDP_set
    __swig_getmethods__["baseDP"] = _carlsim.GroupNeuromodulatorInfo_baseDP_get
    if _newclass:
        baseDP = _swig_property(_carlsim.GroupNeuromodulatorInfo_baseDP_get, _carlsim.GroupNeuromodulatorInfo_baseDP_set)
    __swig_setmethods__["base5HT"] = _carlsim.GroupNeuromodulatorInfo_base5HT_set
    __swig_getmethods__["base5HT"] = _carlsim.GroupNeuromodulatorInfo_base5HT_get
    if _newclass:
        base5HT = _swig_property(_carlsim.GroupNeuromodulatorInfo_base5HT_get, _carlsim.GroupNeuromodulatorInfo_base5HT_set)
    __swig_setmethods__["baseACh"] = _carlsim.GroupNeuromodulatorInfo_baseACh_set
    __swig_getmethods__["baseACh"] = _carlsim.GroupNeuromodulatorInfo_baseACh_get
    if _newclass:
        baseACh = _swig_property(_carlsim.GroupNeuromodulatorInfo_baseACh_get, _carlsim.GroupNeuromodulatorInfo_baseACh_set)
    __swig_setmethods__["baseNE"] = _carlsim.GroupNeuromodulatorInfo_baseNE_set
    __swig_getmethods__["baseNE"] = _carlsim.GroupNeuromodulatorInfo_baseNE_get
    if _newclass:
        baseNE = _swig_property(_carlsim.GroupNeuromodulatorInfo_baseNE_get, _carlsim.GroupNeuromodulatorInfo_baseNE_set)
    __swig_setmethods__["decayDP"] = _carlsim.GroupNeuromodulatorInfo_decayDP_set
    __swig_getmethods__["decayDP"] = _carlsim.GroupNeuromodulatorInfo_decayDP_get
    if _newclass:
        decayDP = _swig_property(_carlsim.GroupNeuromodulatorInfo_decayDP_get, _carlsim.GroupNeuromodulatorInfo_decayDP_set)
    __swig_setmethods__["decay5HT"] = _carlsim.GroupNeuromodulatorInfo_decay5HT_set
    __swig_getmethods__["decay5HT"] = _carlsim.GroupNeuromodulatorInfo_decay5HT_get
    if _newclass:
        decay5HT = _swig_property(_carlsim.GroupNeuromodulatorInfo_decay5HT_get, _carlsim.GroupNeuromodulatorInfo_decay5HT_set)
    __swig_setmethods__["decayACh"] = _carlsim.GroupNeuromodulatorInfo_decayACh_set
    __swig_getmethods__["decayACh"] = _carlsim.GroupNeuromodulatorInfo_decayACh_get
    if _newclass:
        decayACh = _swig_property(_carlsim.GroupNeuromodulatorInfo_decayACh_get, _carlsim.GroupNeuromodulatorInfo_decayACh_set)
    __swig_setmethods__["decayNE"] = _carlsim.GroupNeuromodulatorInfo_decayNE_set
    __swig_getmethods__["decayNE"] = _carlsim.GroupNeuromodulatorInfo_decayNE_get
    if _newclass:
        decayNE = _swig_property(_carlsim.GroupNeuromodulatorInfo_decayNE_get, _carlsim.GroupNeuromodulatorInfo_decayNE_set)

    def __init__(self):
        this = _carlsim.new_GroupNeuromodulatorInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_GroupNeuromodulatorInfo
    __del__ = lambda self: None
GroupNeuromodulatorInfo_swigregister = _carlsim.GroupNeuromodulatorInfo_swigregister
GroupNeuromodulatorInfo_swigregister(GroupNeuromodulatorInfo)

class ExpCurve(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpCurve, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpCurve, name)
    __repr__ = _swig_repr

    def __init__(self, _alphaPlus: 'float', _tauPlus: 'float', _alphaMinus: 'float', _tauMinus: 'float'):
        this = _carlsim.new_ExpCurve(_alphaPlus, _tauPlus, _alphaMinus, _tauMinus)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["stdpCurve"] = _carlsim.ExpCurve_stdpCurve_set
    __swig_getmethods__["stdpCurve"] = _carlsim.ExpCurve_stdpCurve_get
    if _newclass:
        stdpCurve = _swig_property(_carlsim.ExpCurve_stdpCurve_get, _carlsim.ExpCurve_stdpCurve_set)
    __swig_setmethods__["alphaPlus"] = _carlsim.ExpCurve_alphaPlus_set
    __swig_getmethods__["alphaPlus"] = _carlsim.ExpCurve_alphaPlus_get
    if _newclass:
        alphaPlus = _swig_property(_carlsim.ExpCurve_alphaPlus_get, _carlsim.ExpCurve_alphaPlus_set)
    __swig_setmethods__["tauPlus"] = _carlsim.ExpCurve_tauPlus_set
    __swig_getmethods__["tauPlus"] = _carlsim.ExpCurve_tauPlus_get
    if _newclass:
        tauPlus = _swig_property(_carlsim.ExpCurve_tauPlus_get, _carlsim.ExpCurve_tauPlus_set)
    __swig_setmethods__["alphaMinus"] = _carlsim.ExpCurve_alphaMinus_set
    __swig_getmethods__["alphaMinus"] = _carlsim.ExpCurve_alphaMinus_get
    if _newclass:
        alphaMinus = _swig_property(_carlsim.ExpCurve_alphaMinus_get, _carlsim.ExpCurve_alphaMinus_set)
    __swig_setmethods__["tauMinus"] = _carlsim.ExpCurve_tauMinus_set
    __swig_getmethods__["tauMinus"] = _carlsim.ExpCurve_tauMinus_get
    if _newclass:
        tauMinus = _swig_property(_carlsim.ExpCurve_tauMinus_get, _carlsim.ExpCurve_tauMinus_set)
    __swig_destroy__ = _carlsim.delete_ExpCurve
    __del__ = lambda self: None
ExpCurve_swigregister = _carlsim.ExpCurve_swigregister
ExpCurve_swigregister(ExpCurve)

class TimingBasedCurve(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimingBasedCurve, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimingBasedCurve, name)
    __repr__ = _swig_repr

    def __init__(self, _alphaPlus: 'float', _tauPlus: 'float', _alphaMinus: 'float', _tauMinus: 'float', _gamma: 'float'):
        this = _carlsim.new_TimingBasedCurve(_alphaPlus, _tauPlus, _alphaMinus, _tauMinus, _gamma)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["stdpCurve"] = _carlsim.TimingBasedCurve_stdpCurve_set
    __swig_getmethods__["stdpCurve"] = _carlsim.TimingBasedCurve_stdpCurve_get
    if _newclass:
        stdpCurve = _swig_property(_carlsim.TimingBasedCurve_stdpCurve_get, _carlsim.TimingBasedCurve_stdpCurve_set)
    __swig_setmethods__["alphaPlus"] = _carlsim.TimingBasedCurve_alphaPlus_set
    __swig_getmethods__["alphaPlus"] = _carlsim.TimingBasedCurve_alphaPlus_get
    if _newclass:
        alphaPlus = _swig_property(_carlsim.TimingBasedCurve_alphaPlus_get, _carlsim.TimingBasedCurve_alphaPlus_set)
    __swig_setmethods__["tauPlus"] = _carlsim.TimingBasedCurve_tauPlus_set
    __swig_getmethods__["tauPlus"] = _carlsim.TimingBasedCurve_tauPlus_get
    if _newclass:
        tauPlus = _swig_property(_carlsim.TimingBasedCurve_tauPlus_get, _carlsim.TimingBasedCurve_tauPlus_set)
    __swig_setmethods__["alphaMinus"] = _carlsim.TimingBasedCurve_alphaMinus_set
    __swig_getmethods__["alphaMinus"] = _carlsim.TimingBasedCurve_alphaMinus_get
    if _newclass:
        alphaMinus = _swig_property(_carlsim.TimingBasedCurve_alphaMinus_get, _carlsim.TimingBasedCurve_alphaMinus_set)
    __swig_setmethods__["tauMinus"] = _carlsim.TimingBasedCurve_tauMinus_set
    __swig_getmethods__["tauMinus"] = _carlsim.TimingBasedCurve_tauMinus_get
    if _newclass:
        tauMinus = _swig_property(_carlsim.TimingBasedCurve_tauMinus_get, _carlsim.TimingBasedCurve_tauMinus_set)
    __swig_setmethods__["gamma"] = _carlsim.TimingBasedCurve_gamma_set
    __swig_getmethods__["gamma"] = _carlsim.TimingBasedCurve_gamma_get
    if _newclass:
        gamma = _swig_property(_carlsim.TimingBasedCurve_gamma_get, _carlsim.TimingBasedCurve_gamma_set)
    __swig_destroy__ = _carlsim.delete_TimingBasedCurve
    __del__ = lambda self: None
TimingBasedCurve_swigregister = _carlsim.TimingBasedCurve_swigregister
TimingBasedCurve_swigregister(TimingBasedCurve)

class PulseCurve(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PulseCurve, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PulseCurve, name)
    __repr__ = _swig_repr

    def __init__(self, _betaLTP: 'float', _betaLTD: 'float', _lambda: 'float', _delta: 'float'):
        this = _carlsim.new_PulseCurve(_betaLTP, _betaLTD, _lambda, _delta)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["stdpCurve"] = _carlsim.PulseCurve_stdpCurve_set
    __swig_getmethods__["stdpCurve"] = _carlsim.PulseCurve_stdpCurve_get
    if _newclass:
        stdpCurve = _swig_property(_carlsim.PulseCurve_stdpCurve_get, _carlsim.PulseCurve_stdpCurve_set)
    __swig_setmethods__["betaLTP"] = _carlsim.PulseCurve_betaLTP_set
    __swig_getmethods__["betaLTP"] = _carlsim.PulseCurve_betaLTP_get
    if _newclass:
        betaLTP = _swig_property(_carlsim.PulseCurve_betaLTP_get, _carlsim.PulseCurve_betaLTP_set)
    __swig_setmethods__["betaLTD"] = _carlsim.PulseCurve_betaLTD_set
    __swig_getmethods__["betaLTD"] = _carlsim.PulseCurve_betaLTD_get
    if _newclass:
        betaLTD = _swig_property(_carlsim.PulseCurve_betaLTD_get, _carlsim.PulseCurve_betaLTD_set)
    __swig_setmethods__["_lambda"] = _carlsim.PulseCurve__lambda_set
    __swig_getmethods__["_lambda"] = _carlsim.PulseCurve__lambda_get
    if _newclass:
        _lambda = _swig_property(_carlsim.PulseCurve__lambda_get, _carlsim.PulseCurve__lambda_set)
    __swig_setmethods__["delta"] = _carlsim.PulseCurve_delta_set
    __swig_getmethods__["delta"] = _carlsim.PulseCurve_delta_get
    if _newclass:
        delta = _swig_property(_carlsim.PulseCurve_delta_get, _carlsim.PulseCurve_delta_set)
    __swig_destroy__ = _carlsim.delete_PulseCurve
    __del__ = lambda self: None
PulseCurve_swigregister = _carlsim.PulseCurve_swigregister
PulseCurve_swigregister(PulseCurve)

class RangeWeight(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RangeWeight, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RangeWeight, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _carlsim.new_RangeWeight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["min"] = _carlsim.RangeWeight_min_set
    __swig_getmethods__["min"] = _carlsim.RangeWeight_min_get
    if _newclass:
        min = _swig_property(_carlsim.RangeWeight_min_get, _carlsim.RangeWeight_min_set)
    __swig_setmethods__["init"] = _carlsim.RangeWeight_init_set
    __swig_getmethods__["init"] = _carlsim.RangeWeight_init_get
    if _newclass:
        init = _swig_property(_carlsim.RangeWeight_init_get, _carlsim.RangeWeight_init_set)
    __swig_setmethods__["max"] = _carlsim.RangeWeight_max_set
    __swig_getmethods__["max"] = _carlsim.RangeWeight_max_get
    if _newclass:
        max = _swig_property(_carlsim.RangeWeight_max_get, _carlsim.RangeWeight_max_set)
    __swig_destroy__ = _carlsim.delete_RangeWeight
    __del__ = lambda self: None
RangeWeight_swigregister = _carlsim.RangeWeight_swigregister
RangeWeight_swigregister(RangeWeight)

class RangeDelay(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RangeDelay, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RangeDelay, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _carlsim.new_RangeDelay(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["min"] = _carlsim.RangeDelay_min_set
    __swig_getmethods__["min"] = _carlsim.RangeDelay_min_get
    if _newclass:
        min = _swig_property(_carlsim.RangeDelay_min_get, _carlsim.RangeDelay_min_set)
    __swig_setmethods__["max"] = _carlsim.RangeDelay_max_set
    __swig_getmethods__["max"] = _carlsim.RangeDelay_max_get
    if _newclass:
        max = _swig_property(_carlsim.RangeDelay_max_get, _carlsim.RangeDelay_max_set)
    __swig_destroy__ = _carlsim.delete_RangeDelay
    __del__ = lambda self: None
RangeDelay_swigregister = _carlsim.RangeDelay_swigregister
RangeDelay_swigregister(RangeDelay)

class RadiusRF(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadiusRF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RadiusRF, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _carlsim.new_RadiusRF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["radX"] = _carlsim.RadiusRF_radX_set
    __swig_getmethods__["radX"] = _carlsim.RadiusRF_radX_get
    if _newclass:
        radX = _swig_property(_carlsim.RadiusRF_radX_get, _carlsim.RadiusRF_radX_set)
    __swig_setmethods__["radY"] = _carlsim.RadiusRF_radY_set
    __swig_getmethods__["radY"] = _carlsim.RadiusRF_radY_get
    if _newclass:
        radY = _swig_property(_carlsim.RadiusRF_radY_get, _carlsim.RadiusRF_radY_set)
    __swig_setmethods__["radZ"] = _carlsim.RadiusRF_radZ_set
    __swig_getmethods__["radZ"] = _carlsim.RadiusRF_radZ_get
    if _newclass:
        radZ = _swig_property(_carlsim.RadiusRF_radZ_get, _carlsim.RadiusRF_radZ_set)
    __swig_destroy__ = _carlsim.delete_RadiusRF
    __del__ = lambda self: None
RadiusRF_swigregister = _carlsim.RadiusRF_swigregister
RadiusRF_swigregister(RadiusRF)

class RangeRmem(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RangeRmem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RangeRmem, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _carlsim.new_RangeRmem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _carlsim.delete_RangeRmem
    __del__ = lambda self: None
RangeRmem_swigregister = _carlsim.RangeRmem_swigregister
RangeRmem_swigregister(RangeRmem)

# This file is compatible with both classic and new-style classes.


